
# Hashing

    Key Idea: Use hash maps or sets to optimize lookups and data storage.
    Examples:
        Two Sum
        Longest Subarray with Sum Zero
        Group Anagrams
        Subarray Sums Divisible by K

# Monotonic Stack/Queue

    Key Idea: Use stacks or queues to solve problems involving sequences with a monotonic property.
    Examples:
        Next Greater Element
        Largest Rectangle in Histogram
        Trapping Rain Water
        Sliding Window Maximum

# BFS/DFS for Trees

    Key Idea: Use traversal techniques for solving hierarchical data structure problems.
    Examples:
        Lowest Common Ancestor
        Binary Tree Zigzag Level Order Traversal
        Maximum Depth of a Binary Tree
        Path Sum Problems


# Two Pointers Pattern 
    Key Idea: Use two pointers i and j to iterate over a DS ( to separate between elements based on conditions )
    Examples:

        Removing duplicates from a sorted list.
        Detecting cycles in a linked list (Floyd's Tortoise and Hare Algorithm).
        Segregate even and odd nodes in a Linked List 
        Merging two sorted arrays.
        Partitioning an array (e.g., moving all negatives to one side).
        Reversing vowels in a string.
        Checking for palindromes.
        Two Sum II - Input Array Is Sorted 
        Container With Most Water 
        Remove Duplicates from Sorted Array
        Next Permutation 
        Trapping Rain Water

# Divide and Conquer

    Key Idea: Break the problem into smaller subproblems, solve them independently, and combine the results.
    Examples:
        Merge Sort 
        Quick Sort 
        Binary Search 
        Matrix Exponentiation

# Sliding Window

    Key Idea: Use a window (a subset of data) to solve problems involving arrays or strings, moving the window to include/exclude elements efficiently.
    Examples:
        Maximum Sum Subarray (Kadane's Algorithm) 
        Longest Substring Without Repeating Characters
        Minimum Window Substring
        Sliding Window Maximum

# Heap/Priority Queue

    Key Idea: Use heaps to efficiently solve problems requiring frequent access to the smallest or largest element.
    Examples:
        Top K Elements
        Merge K Sorted Lists
        Median in a Stream
        Dijkstra's Algorithm

# Graph Algorithms

    Key Idea: Use specialized algorithms to traverse or optimize problems involving graphs.
    Examples:
        Breadth-First Search problems (BFS)
        Depth-First Search problems (DFS)
        Kruskal's and Prim's Algorithms (Minimum Spanning Tree)
        Bellman-Ford and Floyd-Warshall (Shortest Paths)

# Dynamic Programming (DP)

    Key Idea: Solve problems by breaking them into overlapping subproblems, store intermediate results (memoization or tabulation), and reuse them to avoid redundant calculations.
    Examples:
        Longest Common Subsequence (LCS)
        0/1 Knapsack Problem
        Fibonacci Sequence (Bottom-Up or Top-Down)
        Minimum Path Sum in a Grid

# Greedy Algorithms

    Key Idea: Make a locally optimal choice at each step, aiming for a globally optimal solution.
    Examples:
        Huffman Coding
        Dijkstra's Algorithm (for shortest paths)
        Activity Selection Problem
        Fractional Knapsack

# Backtracking

    Key Idea: Explore all possibilities for solving a problem and backtrack when you encounter a dead end.
    Examples:
        N-Queens Problem
        Sudoku Solver
        Subset Generation
        Permutations and Combinations


# Union-Find (Disjoint Set Union, DSU)

    Key Idea: Efficiently manage disjoint sets for problems requiring connectivity checks or clustering.
    Examples:
        Kruskal’s Algorithm
        Detecting Cycles in Graphs
        Number of Connected Components

# Bit Manipulation

    Key Idea: Use binary operations to solve problems efficiently.
    Examples:
        Find the Single Number (XOR Trick)
        Subset Generation (using binary masks)
        Count Set Bits
        Power of Two Check

# Sorting-Based

    Key Idea: Leverage sorting as a preprocessing step to simplify problems.
    Examples:
        Two Sum (Sorted Array + Two Pointers) 
        Meeting Rooms Problem
        Kth Largest Element in an Array
        Merge Intervals

# Recursion

    Key Idea: Solve problems by repeatedly breaking them down into simpler, smaller problems.
    Examples:
        Tower of Hanoi
        Generate Parentheses
        DFS (Recursive Implementation)
        Permutations and Combinations

# Mathematical Algorithms

    Key Idea: Use mathematical properties to derive efficient solutions.
    Examples:
        Greatest Common Divisor (GCD) using Euclid’s Algorithm
        Sieve of Eratosthenes (Prime Numbers)
        Fast Exponentiation
        Fibonacci Numbers (Matrix Exponentiation)

# Prefix Sum and Difference Array

    Key Idea: Use precomputed cumulative sums/differences to optimize range queries.
    Examples:
        Range Sum Query (1D and 2D)
        Subarray Sum Equals K
        Difference Array for Range Updates




# Randomized Algorithms

    Key Idea: Use randomness to simplify algorithms or improve performance probabilistically.
    Examples:
        Randomized Quick Sort
        Reservoir Sampling
        Monte Carlo Algorithms
        Randomized Algorithms for Median



# Segment Trees/Fenwick Trees

    Key Idea: Use tree-like data structures for efficient range queries and updates.
    Examples:
        Range Minimum Query (RMQ)
        Range Sum Query
        Inversion Count

# String Matching Algorithms

    Key Idea: Use pattern-matching techniques for strings.
    Examples:
        Rabin-Karp Algorithm
        Knuth-Morris-Pratt (KMP)
        Longest Prefix Suffix (LPS) Array
        Z-Algorithm



References :

Arunkumar RajendranArunkumar Rajendran  
Bookmark this post, this is a great list of problems for OAs and Coding interviews. 

► Dynamic Programming (45 Problems)

https://lnkd.in/gHYgRDSZ  https://leetcode.com/problem-list/9x5spweh/

► Greedy Algorithms (34 Problems)

https://lnkd.in/gianQPuw   https://leetcode.com/problem-list/925p7hr1/

► Graphs (32 Problems)

https://lnkd.in/gcHRz5-p  https://leetcode.com/problem-list/9x1uea1h/

► Backtracking (17 Problems)

https://lnkd.in/gersVnrz   https://leetcode.com/problem-list/9x9qz3md/

► Linked List (13 Problems)

https://lnkd.in/gT_FhqYa   https://leetcode.com/problem-list/9rizphpj/

► Bit Manipulation (21 Problems)

https://lnkd.in/gtZZc6tR   https://leetcode.com/problem-list/92qvw6c6/

► Hash Table and Map (46 Problems)

https://lnkd.in/gPsUh6w5   https://leetcode.com/problem-list/504wrexe/

► Disjoint Set Union (Union Find) (25 Problems)

https://lnkd.in/gQx74mJc   https://leetcode.com/problem-list/5lhmb4mj/

► Bridges and Articulation Points (4 Problems)

https://lnkd.in/gRpJ6qxN   https://leetcode.com/problem-list/9id9ahz7/

► Dijkstra Algorithm (13 Problems)

https://lnkd.in/gRsxH7Th  https://leetcode.com/problem-list/9id5lube/

► Bellman Ford Algorithm (5 Problems)

https://lnkd.in/gBN54_mc   https://leetcode.com/problem-list/9id9smj2/

► Floyd Warshall Algorithm (6 Problems)

https://lnkd.in/g6zvRYbb    https://leetcode.com/problem-list/9idenloe/

► Topological Sort (4 Problems)

https://lnkd.in/gBaaZCbM   https://leetcode.com/problem-list/9idxg95s/

► Sliding Window (12 Problems)

https://lnkd.in/gbMnsS8i   https://leetcode.com/problem-list/x1lbzfk3/

► Trie (8 Problems)

https://lnkd.in/gDqU7Ypy   https://leetcode.com/problem-list/5uyupjcr/

► Monotonic Queue and Priority Queue (13 Problems)

https://lnkd.in/gzrcfZtj    https://leetcode.com/problem-list/9rt1jt27/

► Heaps (22 Problems)

https://lnkd.in/gNsjGw8p   https://leetcode.com/problem-list/93chilpi/

► Trees (Top 26 Problems)
https://lnkd.in/g5vXWFu3   https://leetcode.com/problem-list/9ak7i9wv/

► Trees (Top 74 Problems)
Trees Top 74 Problems

► Binary Search (25 Problems)
https://lnkd.in/gjykw7x2  https://leetcode.com/problem-list/9ixr4vaj/

► Two Pointers (30 Problems)
https://lnkd.in/gZeG-PXb   https://leetcode.com/problem-list/9ns2k47r/

https://leetcode.com/u/joseph_cristiano/